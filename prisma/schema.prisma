// Synth-Dojo Prisma Schema
// Real-time coding learning platform with AI battles and PvP matches

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
}

// Auth models for NextAuth
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime
  
  @@unique([identifier, token])
}

// Core User model
model User {
  id              String    @id @default(cuid())
  email           String    @unique
  name            String?
  emailVerified   DateTime?
  image           String?
  hashedPassword  String?
  role            String    @default("user")
  points          Int       @default(0)
  level           Int       @default(1)
  hp              Int       @default(5)
  streak          Int       @default(0)
  lastActiveDate  DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  accounts        Account[]
  sessions        Session[]
  profile         Profile?
  matches         Match[]   @relation("userMatches")
  submissions     MatchSubmission[]
  achievements    UserAchievement[]
  progress        UserProgress[]
}

model Profile {
  id        String   @id @default(cuid())
  userId    String   @unique
  bio       String?
  avatar    String?
  country   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Learning module models
model Module {
  id          String   @id @default(cuid())
  title       String
  description String?
  order       Int      @default(0)
  difficulty  Int      @default(1)
  isPublished Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  lessons  Lesson[]
  progress UserProgress[]
}

model Lesson {
  id          String   @id @default(cuid())
  moduleId    String
  title       String
  content     String   @db.Text
  codeExample String?  @db.Text
  order       Int      @default(0)
  isPublished Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  module    Module @relation(fields: [moduleId], references: [id], onDelete: Cascade)
  questions Question[]
}

model Question {
  id           String   @id @default(cuid())
  lessonId     String?
  title        String
  prompt       String   @db.Text
  starterCode  String?  @db.Text
  testCases    String   @db.Text
  difficulty   Int      @default(1)
  points       Int      @default(10)
  timeLimit    Int      @default(300)
  isPublished  Boolean  @default(false)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  lesson       Lesson?  @relation(fields: [lessonId], references: [id], onDelete: SetNull)
  hints        Hint[]
  matchQuestions MatchQuestion[]
}

model Hint {
  id         String   @id @default(cuid())
  questionId String
  content    String   @db.Text
  order      Int      @default(0)
  pointCost  Int      @default(5)
  createdAt  DateTime @default(now())
  
  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
}

// Match and battle models
model Match {
  id          String   @id @default(cuid())
  mode        String   // "practice", "ai_battle", "pvp"
  status      String   @default("waiting") // "waiting", "in_progress", "completed", "cancelled"
  winnerId    String?
  roomCode    String?  @unique
  startedAt   DateTime?
  completedAt DateTime?
  createdAt   DateTime @default(now())
  
  participants MatchParticipant[]
  questions    MatchQuestion[]
  submissions  MatchSubmission[]
  winner       User?    @relation("userMatches", fields: [winnerId], references: [id])
}

model MatchParticipant {
  id        String   @id @default(cuid())
  matchId   String
  userId    String
  isAI      Boolean  @default(false)
  isReady   Boolean  @default(false)
  score     Int      @default(0)
  createdAt DateTime @default(now())
  
  match Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  
  @@unique([matchId, userId])
}

model MatchQuestion {
  id         String   @id @default(cuid())
  matchId    String
  questionId String
  order      Int      @default(0)
  
  match    Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  question Question @relation(fields: [questionId], references: [id])
  
  @@unique([matchId, questionId])
}

model MatchSubmission {
  id          String   @id @default(cuid())
  matchId     String
  userId      String
  questionId  String
  code        String   @db.Text
  language    String   @default("javascript")
  isCorrect   Boolean  @default(false)
  score       Int      @default(0)
  runtimeMs   Int      @default(0)
  styleScore  Int      @default(0)
  output      String?  @db.Text
  error       String?  @db.Text
  createdAt   DateTime @default(now())
  
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  match Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
}

// Progress tracking
model UserProgress {
  id          String   @id @default(cuid())
  userId      String
  moduleId    String
  isCompleted Boolean  @default(false)
  progress    Int      @default(0)
  lastVisited DateTime @default(now())
  createdAt   DateTime @default(now())
  
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  module Module @relation(fields: [moduleId], references: [id], onDelete: Cascade)
  
  @@unique([userId, moduleId])
}

// Gamification
model Achievement {
  id          String   @id @default(cuid())
  name        String   @unique
  description String
  icon        String?
  points      Int      @default(0)
  criteria    String   @db.Text
  createdAt   DateTime @default(now())
  
  userAchievements UserAchievement[]
}

model UserAchievement {
  id            String   @id @default(cuid())
  userId        String
  achievementId String
  unlockedAt    DateTime @default(now())
  
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  achievement Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)
  
  @@unique([userId, achievementId])
}

// Leaderboard (materialized view alternative)
model LeaderboardEntry {
  id        String   @id @default(cuid())
  userId    String   @unique
  rank      Int      @default(0)
  points    Int      @default(0)
  level     Int      @default(1)
  wins      Int      @default(0)
  losses    Int      @default(0)
  updatedAt DateTime @updatedAt
  
  @@index([points, level])
}
